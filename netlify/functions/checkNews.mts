import { Config, Context } from "@netlify/functions";
import { parseHTML } from "linkedom";
import { Redis } from "@upstash/redis";
import { toDate, format as formatDateFns, utcToZonedTime } from "date-fns-tz";
import { ErrorWithStatusCode, escapeHTML } from "../../utils";

// Secret token can be generated by running:
// `openssl rand -base64 256 | tr -dc 'A-Za-z0-9_-' | head -c 256`
const SECRET_TOKEN = process.env["SECRET_TOKEN"];
const TZ = process.env["TZ"] || "Asia/Jerusalem";
const TELEGRAM_BOT_TOKEN = process.env["TELEGRAM_BOT_TOKEN"]!;
const TELEGRAM_CHAT_ID = parseInt(process.env["TELEGRAM_CHAT_ID"]!);

const redis = new Redis({
  url: process.env["UPSTASH_URL"]!,
  token: process.env["UPSTASH_TOKEN"]!,
});
const REDIS_LAST_SEEN_ARTICLE_ID_KEY = "lastSeenArticleId";

type Article = {
  articleId: string;
  date: Date;
  text: string;
  title: string;
  shareUrl: string;
};

async function sendTelegramMessage(message: string, tag: string) {
  const telegramApiUrl = `https://api.telegram.org/bot${TELEGRAM_BOT_TOKEN}/sendMessage`;
  const requestBody = JSON.stringify({
    text: message,
    parse_mode: "HTML",
    disable_web_page_preview: true,
    chat_id: TELEGRAM_CHAT_ID,
  });
  const timingLabel = `POST ${telegramApiUrl.replace(
    TELEGRAM_BOT_TOKEN,
    "***"
  )} for ${tag}`;
  console.time(timingLabel);
  console.log(`${timingLabel} body: ${requestBody}`);
  const telegramResponse = await fetch(telegramApiUrl, {
    method: "POST",
    headers: {
      "Content-Type": "application/json",
    },
    body: requestBody,
  });
  console.timeEnd(timingLabel);
  console.log(`${timingLabel} returned status ${telegramResponse.status}`);
  if (telegramResponse.status < 200 || telegramResponse.status >= 300) {
    console.log(
      `${timingLabel} returned body: ${await telegramResponse.text()}`
    );
    throw Error(
      `Telegram sendMessage returned status ${telegramResponse.status}`
    );
  }
}

async function sendArticleViaTelegram(article: Article) {
  const formattedDateTime = formatDateFns(
    article.date,
    "dd/MM/yyyy בשעה HH:mm:ss",
    { timeZone: "Asia/Jerusalem" }
  );
  const message = `<b>🌟 <a href="${article.shareUrl}">מבזק</a> מ-${escapeHTML(
    formattedDateTime
  )}:</b>\n<b>${escapeHTML(article.title)}</b>\n${escapeHTML(article.text)}`;
  await sendTelegramMessage(message, `article ${article.articleId}`);
}

async function getNewsFeedHTML(): Promise<string> {
  const newsFeedUrl = "https://www.ynet.co.il/news/category/184";
  const timingLabel = `GET ${newsFeedUrl}`;
  console.time(timingLabel);
  const newsResponseText = await (
    await fetch("https://www.ynet.co.il/news/category/184", {
      headers: {
        accept:
          "text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7",
        "accept-language": "en-US,en;q=0.9,he;q=0.8",
        "cache-control": "no-cache",
        pragma: "no-cache",
        "sec-ch-ua": '"Chromium";v="117", "Not;A=Brand";v="8"',
        "sec-ch-ua-mobile": "?0",
        "sec-ch-ua-platform": '"macOS"',
        "sec-fetch-dest": "document",
        "sec-fetch-mode": "navigate",
        "sec-fetch-site": "none",
        "sec-fetch-user": "?1",
        "upgrade-insecure-requests": "1",
      },
      referrerPolicy: "strict-origin-when-cross-origin",
      body: null,
      method: "GET",
      mode: "cors",
      credentials: "include",
    })
  ).text();
  console.timeEnd(timingLabel);
  return newsResponseText;
}

function parseNews(newsResponseText: string): Article[] {
  const timingLabel = "parseNews";
  console.time(timingLabel);
  const newsFeedDOM = parseHTML(newsResponseText);
  const SCRIPT_REGEX = new RegExp(
    /^\w*window\.YITSiteWidgets\.push\(\['[a-zA-Z0-9]+', *'Accordion', *(\{.+\})\]\);$/
  );
  const newsJsonAsText = Array.from(
    newsFeedDOM.window.document.getElementsByTagName("script")
  )
    .filter((elm) => elm.innerHTML.match(SCRIPT_REGEX))[0]
    .innerHTML.match(SCRIPT_REGEX)![1];
  const news = JSON.parse(
    newsJsonAsText.replace(new RegExp('\\"', "g"), '"')
  ).items.map(({ date, ...obj }) => ({
    ...obj,
    date: utcToZonedTime(toDate(date), TZ),
  }));
  console.timeEnd(timingLabel);
  return news;
}

async function dropSeenArticles(articles: Article[]) {
  const timingLabel = `Get ${REDIS_LAST_SEEN_ARTICLE_ID_KEY}`;
  console.time(timingLabel);
  const lastSeenArticleId =
    (await redis.get<string>(REDIS_LAST_SEEN_ARTICLE_ID_KEY)) ||
    articles[Math.min(articles.length, 6)].articleId;
  console.timeEnd(timingLabel);
  return articles
    .slice(
      0,
      articles.findIndex((article) => article.articleId === lastSeenArticleId)
    )
    .sort((a1, a2) => a1.date.getTime() - a2.date.getTime());
}

async function sendNewArticlesViaTelegram(
  requestSource: RequestSource,
  articles: Article[]
) {
  for (const newArticle of articles) {
    await sendArticleViaTelegram(newArticle);
    await updateLastSeenArticleId(articles[0].articleId)
  }
  if (requestSource === RequestSource.BOT && articles.length === 0) {
    await sendTelegramMessage("אין מבזקים חדשים", "no new articles");
  }
}

async function updateLastSeenArticleId(newLastSeenArticleId: string) {
  const timingLabel = `Set ${REDIS_LAST_SEEN_ARTICLE_ID_KEY}`;
  console.time(timingLabel);
  await redis.set(REDIS_LAST_SEEN_ARTICLE_ID_KEY, newLastSeenArticleId);
  console.timeEnd(timingLabel);
}

enum RequestSource {
  BOT = "bot",
  CRON = "cron",
}

enum Action {
  REFRESH = "refresh",
}

const isAuthorized = (req: Request, source: RequestSource) =>
  SECRET_TOKEN === undefined ||
  req.headers.get(
    source === RequestSource.CRON
      ? "X-Secret-Token"
      : "X-Telegram-Bot-Api-Secret-Token"
  ) === SECRET_TOKEN;

function getBotCommand({
  entities,
  text,
}: {
  entities?: { offset: number; length: number; type: string }[];
  text: string;
}) {
  const entity = (entities ?? []).find(
    (entity) => entity.type === "bot_command"
  );
  if (!entity) {
    return null;
  }
  const result = text.slice(entity.offset, entity.offset + entity.length);
  console.log(JSON.stringify({ text, entities, entity, result }));
  return result;
}

async function getRequestSourceAndAction(
  req: Request,
  context: Context
): Promise<{ action: Action; requestSource: RequestSource }> | never {
  const requestSource: RequestSource | undefined =
    RequestSource[context.params.source.toLocaleUpperCase()];
  console.log(`Request source is ${requestSource}`);
  if (!requestSource) {
    throw new ErrorWithStatusCode("Not Found", 404);
  }

  if (!isAuthorized(req, requestSource)) {
    throw new ErrorWithStatusCode("Unauthorized", 401);
  }
  if (requestSource === RequestSource.BOT) {
    const requestBody = await req.json();
    const message = requestBody.message ?? requestBody.channel_post;
    if (message.chat.id !== TELEGRAM_CHAT_ID) {
      console.log(`Blocked webhook from chat id ${message.chat.id}`);
      throw new ErrorWithStatusCode("Permission denied based on chat ID", 403);
    }
    const command = getBotCommand(message);
    if (command !== null) {
      const action: Action | undefined =
        Action[command.replace(/^\//, "").toLocaleUpperCase()];
      if (action !== undefined) {
        return { action, requestSource };
      }
    }
    await sendTelegramMessage(
      "בשביל ליזום עדכון צריך להשתמש בפקודה /refresh\nבשביל לקבל סיכום של היממה האחרונה יש להשתמש בפקודה /digest",
      "unknown command"
    );
    throw new ErrorWithStatusCode("Ignoring unknown command", 200);
  } else {
    return { action: Action.REFRESH, requestSource };
  }
}

async function handleRefresh(
  requestSource: RequestSource,
  articles: Article[]
) {
  const newArticles = await dropSeenArticles(articles);
  await sendNewArticlesViaTelegram(requestSource, newArticles);
  return new Response(JSON.stringify({ newArticles }, undefined, 2));
}

async function handleAction(
  action: Action,
  requestSource: RequestSource,
  articles: Article[]
) {
  switch (action) {
    case Action.REFRESH:
      return handleRefresh(requestSource, articles);
    default:
      throw new Error(`Unknown action: ${action}`);
  }
}

export default async (req: Request, context: Context) => {
  try {
    const { action, requestSource } = await getRequestSourceAndAction(
      req,
      context
    );
    const newsResponseText = await getNewsFeedHTML();
    const articles = parseNews(newsResponseText);
    return handleAction(action, requestSource, articles);
  } catch (e: any) {
    if (e instanceof ErrorWithStatusCode) {
      return new Response(e.message, { status: e.statusCode });
    }
    throw e;
  }
};

export const config: Config = {
  path: "/checkNews/:source",
};
