import { Config, Context } from "@netlify/functions";
import { parseHTML } from "linkedom";
import { Redis } from "@upstash/redis";
import { toDate, format as formatDateFns, utcToZonedTime } from "date-fns-tz";
import { escapeHTML } from "../../utils";

// Secret token can be generated by running:
// `openssl rand -base64 256 | tr -dc 'A-Za-z0-9_-' | head -c 256`
const SECRET_TOKEN = process.env["SECRET_TOKEN"];
const TZ = process.env["TZ"] || "Asia/Jerusalem";
const TELEGRAM_BOT_TOKEN = process.env["TELEGRAM_BOT_TOKEN"]!;
const TELEGRAM_CHAT_ID = process.env["TELEGRAM_CHAT_ID"]!;

const redis = new Redis({
  url: process.env["UPSTASH_URL"]!,
  token: process.env["UPSTASH_TOKEN"]!,
});
const REDIS_LAST_SEEN_ARTICLE_ID_KEY = "lastSeenArticleId";

type Article = {
  articleId: string;
  date: Date;
  text: string;
  title: string;
  shareUrl: string;
};

async function sendTelegramMessage(message: string, tag: string) {
  const telegramApiUrl = `https://api.telegram.org/bot${TELEGRAM_BOT_TOKEN}/sendMessage`;
  const requestBody = JSON.stringify({
    text: message,
    parse_mode: "HTML",
    disable_web_page_preview: true,
    chat_id: TELEGRAM_CHAT_ID,
  });
  const timingLabel = `POST ${telegramApiUrl.replace(
    TELEGRAM_BOT_TOKEN,
    "***"
  )} for ${tag}`;
  console.time(timingLabel);
  console.log(`${timingLabel} body: ${requestBody}`);
  const telegramResponse = await fetch(telegramApiUrl, {
    method: "POST",
    headers: {
      "Content-Type": "application/json",
    },
    body: requestBody,
  });
  console.timeEnd(timingLabel);
  console.log(`${timingLabel} returned status ${telegramResponse.status}`);
  if (telegramResponse.status < 200 || telegramResponse.status >= 300) {
    console.log(
      `${timingLabel} returned body: ${await telegramResponse.text()}`
    );
    throw Error(
      `Telegram sendMessage returned status ${telegramResponse.status}`
    );
  }
}

async function sendArticleViaTelegram(article: Article) {
  const formattedDateTime = formatDateFns(
    article.date,
    "dd/MM/yyyy ×‘×©×¢×” HH:mm:ss",
    { timeZone: "Asia/Jerusalem" }
  );
  const message = `<b>ðŸŒŸ <a href="${article.shareUrl}">×ž×‘×–×§</a> ×ž-${escapeHTML(
    formattedDateTime
  )}:</b>\n<b>${escapeHTML(article.title)}</b>\n${escapeHTML(article.text)}`;
  await sendTelegramMessage(message, `article ${article.articleId}`);
}

async function getNewsFeedHTML(): Promise<string> {
  const newsFeedUrl = "https://www.ynet.co.il/news/category/184";
  const timingLabel = `GET ${newsFeedUrl}`;
  console.time(timingLabel);
  const newsResponseText = await (
    await fetch("https://www.ynet.co.il/news/category/184", {
      headers: {
        accept:
          "text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7",
        "accept-language": "en-US,en;q=0.9,he;q=0.8",
        "cache-control": "no-cache",
        pragma: "no-cache",
        "sec-ch-ua": '"Chromium";v="117", "Not;A=Brand";v="8"',
        "sec-ch-ua-mobile": "?0",
        "sec-ch-ua-platform": '"macOS"',
        "sec-fetch-dest": "document",
        "sec-fetch-mode": "navigate",
        "sec-fetch-site": "none",
        "sec-fetch-user": "?1",
        "upgrade-insecure-requests": "1",
      },
      referrerPolicy: "strict-origin-when-cross-origin",
      body: null,
      method: "GET",
      mode: "cors",
      credentials: "include",
    })
  ).text();
  console.timeEnd(timingLabel);
  return newsResponseText;
}

function parseNews(newsResponseText: string): Article[] {
  const timingLabel = "parseNews";
  console.time(timingLabel);
  const newsFeedDOM = parseHTML(newsResponseText);
  const SCRIPT_REGEX = new RegExp(
    /^\w*window\.YITSiteWidgets\.push\(\['[a-zA-Z0-9]+', *'Accordion', *(\{.+\})\]\);$/
  );
  const newsJsonAsText = Array.from(
    newsFeedDOM.window.document.getElementsByTagName("script")
  )
    .filter((elm) => elm.innerHTML.match(SCRIPT_REGEX))[0]
    .innerHTML.match(SCRIPT_REGEX)![1];
  const news = JSON.parse(
    newsJsonAsText.replace(new RegExp('\\"', "g"), '"')
  ).items.map(({ date, ...obj }) => ({
    ...obj,
    date: utcToZonedTime(toDate(date), TZ),
  }));
  console.timeEnd(timingLabel);
  return news;
}

async function dropSeenArticles(articles: Article[]) {
  const timingLabel = `Get ${REDIS_LAST_SEEN_ARTICLE_ID_KEY}`;
  console.time(timingLabel);
  const lastSeenArticleId =
    (await redis.get<string>(REDIS_LAST_SEEN_ARTICLE_ID_KEY)) ||
    articles[Math.min(articles.length, 6)].articleId;
  console.timeEnd(timingLabel);
  return articles
    .slice(
      0,
      articles.findIndex((article) => article.articleId === lastSeenArticleId)
    )
    .sort((a1, a2) => a1.date.getTime() - a2.date.getTime());
}

async function sendNewArticlesViaTelegram(articles: Article[]) {
  for (const newArticle of articles) {
    await sendArticleViaTelegram(newArticle);
  }
}

async function updateLastSeenArticleId(newLastSeenArticleId: string) {
  const timingLabel = `Set ${REDIS_LAST_SEEN_ARTICLE_ID_KEY}`;
  console.time(timingLabel);
  await redis.set(REDIS_LAST_SEEN_ARTICLE_ID_KEY, newLastSeenArticleId);
  console.timeEnd(timingLabel);
}

enum RequestSource {
  BOT = "bot",
  CRON = "cron",
}

const isAuthorized = (req: Request, source: RequestSource) =>
  SECRET_TOKEN === undefined ||
  req.headers.get(
    source === RequestSource.CRON
      ? "X-Secret-Token"
      : "X-Telegram-Bot-Api-Secret-Token"
  ) === SECRET_TOKEN;

async function getBotCommand(req: Request) {
  const {
    entities,
    text,
  }: {
    entities?: { offset: number; length: number; type: string }[];
    text: string;
  } = await req.json();
  const entity = (entities ?? []).find(
    (entity) => entity.type === "bot_command"
  );
  if (!entity) {
    return null;
  }
  const result = text.slice(entity.offset, entity.offset + entity.length);
  console.log(JSON.stringify({ text, entities, entity, result }));
  return result;
}

async function validateRequestMaybeGetErrorResponse(
  req: Request,
  context: Context
): Promise<Response | null> {
  const requestSource =
    RequestSource[context.params.source.toLocaleUpperCase()];
  console.log(`Request source is ${requestSource}`);
  if (!requestSource) {
    return new Response("Not Found", { status: 404 });
  }
  if (!isAuthorized(req, requestSource)) {
    return new Response("Unauthorized", { status: 401 });
  }
  if (requestSource === RequestSource.BOT) {
    const command = await getBotCommand(req);
    if (command !== "/refresh") {
      if (command !== null) {
        await sendTelegramMessage("Unknown command", "unknown command");
      }
      return new Response("Ignoring unknown command", { status: 200 });
    }
  }
  return null;
}

export default async (req: Request, context: Context) => {
  const errorResponse = await validateRequestMaybeGetErrorResponse(
    req,
    context
  );
  if (errorResponse) {
    return errorResponse;
  }

  const newsResponseText = await getNewsFeedHTML();
  const articles = parseNews(newsResponseText);
  const newArticles = await dropSeenArticles(articles);
  await sendNewArticlesViaTelegram(newArticles);
  await updateLastSeenArticleId(articles[0].articleId);
  return new Response(JSON.stringify({ newArticles }, undefined, 2));
};

export const config: Config = {
  path: "/checkNews/:source",
};
